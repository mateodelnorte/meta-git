#!/usr/bin/env node

const fs = require('fs');
const program = require('commander');
const debug = require('debug')('meta-git-remote');
const loop = require('loop-things');
const path = require('path');
const util = require('util');

// TODO: refactor to standard usage parser, where you can paste in the usage from the wrapped command and it will both output meta usage when given --help and also intelligently 
// compare given syntax against known wrapped command usage to display --help when an incorrect command is given
const usages = `
usage: meta git remote [-v | --verbose]
   or: meta git remote add [-t <branch>] [-m <master>] [-f] [--tags | --no-tags] [--mirror=<fetch|push>] <name> <url>
   or: meta git remote rename <old> <new>
   or: meta git remote remove <name>
   or: meta git remote set-head <name> (-a | --auto | -d | --delete | <branch>)
   or: meta git remote [-v | --verbose] show [-n] <name>
   or: meta git remote prune [-n | --dry-run] <name>
   or: meta git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]
   or: meta git remote set-branches [--add] <name> <branch>...
   or: meta git remote get-url [--push] [--all] <name>
   or: meta git remote set-url [--push] <name> <newurl> [<oldurl>]
   or: meta git remote set-url --add <name> <newurl>
   or: meta git remote set-url --delete <name> <url>

    -v, --verbose         be verbose; must be placed before a subcommand`;

if (process.argv[2] === '--help') return console.log(usages);

var valid = new Set();
valid.add(undefined);
valid.add('-v');
valid.add('add');
valid.add('rename');
valid.add('remove');
valid.add('set-head');
valid.add('show');
valid.add('set-branches');
valid.add('get-url');
valid.add('set-url');

if ( ! valid.has(process.argv[2])) return console.log(usages);

process.argv.shift()
process.argv.shift()

const subCommand = process.argv.join(' ');

var meta = null; 
var buffer = null;

const metaLocation = path.join(process.cwd(), '.meta');

try {
  buffer = fs.readFileSync(metaLocation);
  debug(`.meta file found at ${metaLocation}`);
} catch (e) {
  debug(`no .meta file found at ${metaLocation}: ${e}`);
}

if (buffer) {
  try {
    meta = JSON.parse(buffer.toString());
    debug(`.meta file contents parsed: ${util.inspect(meta, null, Infinity)}`);
  } catch (e) {
    debug(`error parsing .meta JSON: ${e}`);
  }
}

if ( ! meta) return console.error(`No .meta file found in ${process.cwd()}. Are you in a meta repo?`);

const projects = meta.projects;
const folders = Object.keys(projects).map((folder) => { return path.resolve(folder); });

folders.unshift(process.cwd());

loop({
  command: `git remote ${subCommand}`,
  directories: folders
});