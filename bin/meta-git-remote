#!/usr/bin/env node

const fs = require('fs');
const program = require('commander');
const debug = require('debug')('meta-git-remote');
const loop = require('loop-things');
const path = require('path');
const util = require('util');

const usages = `\n  usages:\n
    meta git remote
    meta git remote -v
    meta git remote show origin
    meta git remote rename oldname newname
    meta git remote rm name`;

if (process.argv[2] === '--help')
  return console.log(usages);

let first = process.argv[2] === 'blank' ?
                      process.argv[3] || '':
                      process.argv[2] || '';

const subCommandParsers = {
  '': function (argv) { return '' },
  '-v': function (argv) { return '-v' },
  'show': function (argv) {
    let remote = process.argv[3] === 'blank' ?
                      process.argv[4] || '':
                      process.argv[3] || '';
    return `show ${remote}`;
  },
  'rename': function (argv) {

  },
  'rm': function (argv) {}
}

const subCommandParser = subCommandParsers[first];

if ( ! subCommandParser) return console.log(usages);

const subCommand = subCommandParser(process.argv);

var meta = null; 
var buffer = null;

const metaLocation = path.join(process.cwd(), '.meta');

try {
  buffer = fs.readFileSync(metaLocation);
  debug(`.meta file found at ${metaLocation}`);
} catch (e) {
  debug(`no .meta file found at ${metaLocation}: ${e}`);
}

if (buffer) {
  try {
    meta = JSON.parse(buffer.toString());
    debug(`.meta file contents parsed: ${util.inspect(meta, null, Infinity)}`);
  } catch (e) {
    debug(`error parsing .meta JSON: ${e}`);
  }
}

if ( ! meta) return console.error(`No .meta file found in ${process.cwd()}. Are you in a meta repo?`);

const projects = meta.projects;
const folders = Object.keys(projects).map((folder) => { return path.resolve(folder); });

folders.unshift(process.cwd());

loop({
  command: `git remote ${subCommand}`,
  directories: folders
});